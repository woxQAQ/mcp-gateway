import type { McpConfigModel, McpConfigName } from '../types'

/**
 * Generated by orval v7.10.0 🍺
 * Do not edit manually.
 * API Server
 * OpenAPI spec version: 0.1.0
 */
import { faker } from '@faker-js/faker'

import { delay, http, HttpResponse } from 'msw'
import { McpServerType, Policy } from '../types'

export function getListMcpConfigsApiV1McpConfigsGetResponseMock(): McpConfigModel[] {
  return Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1,
  ).map(() => ({
    created_at: `${faker.date.past().toISOString().split('.')[0]}Z`,
    deleted_at: faker.helpers.arrayElement([
      `${faker.date.past().toISOString().split('.')[0]}Z`,
      null,
    ]),
    gmt_created: `${faker.date.past().toISOString().split('.')[0]}Z`,
    gmt_deleted: faker.helpers.arrayElement([
      faker.helpers.arrayElement([
        `${faker.date.past().toISOString().split('.')[0]}Z`,
        null,
      ]),
      undefined,
    ]),
    gmt_updated: `${faker.date.past().toISOString().split('.')[0]}Z`,
    http_servers: Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => ({
      description: faker.string.alpha({ length: { min: 10, max: 20 } }),
      name: faker.string.alpha({ length: { min: 10, max: 20 } }),
      tools: Array.from(
        { length: faker.number.int({ min: 1, max: 10 }) },
        (_, i) => i + 1,
      ).map(() => faker.string.alpha({ length: { min: 10, max: 20 } })),
      url: faker.string.alpha({ length: { min: 10, max: 20 } }),
    })),
    id: faker.string.alpha({ length: { min: 10, max: 20 } }),
    name: faker.string.alpha({ length: { min: 10, max: 20 } }),
    routers: Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => ({
      cors: {
        allow_credentials: faker.datatype.boolean(),
        allow_headers: Array.from(
          { length: faker.number.int({ min: 1, max: 10 }) },
          (_, i) => i + 1,
        ).map(() => faker.string.alpha({ length: { min: 10, max: 20 } })),
        allow_methods: Array.from(
          { length: faker.number.int({ min: 1, max: 10 }) },
          (_, i) => i + 1,
        ).map(() => faker.string.alpha({ length: { min: 10, max: 20 } })),
        allow_origins: Array.from(
          { length: faker.number.int({ min: 1, max: 10 }) },
          (_, i) => i + 1,
        ).map(() => faker.string.alpha({ length: { min: 10, max: 20 } })),
        expose_headers: Array.from(
          { length: faker.number.int({ min: 1, max: 10 }) },
          (_, i) => i + 1,
        ).map(() => faker.string.alpha({ length: { min: 10, max: 20 } })),
      },
      http_server_ref: {
        description: faker.string.alpha({ length: { min: 10, max: 20 } }),
        name: faker.string.alpha({ length: { min: 10, max: 20 } }),
        tools: Array.from(
          { length: faker.number.int({ min: 1, max: 10 }) },
          (_, i) => i + 1,
        ).map(() => faker.string.alpha({ length: { min: 10, max: 20 } })),
        url: faker.string.alpha({ length: { min: 10, max: 20 } }),
      },
      prefix: faker.string.alpha({ length: { min: 10, max: 20 } }),
      sse_prefix: faker.string.alpha({ length: { min: 10, max: 20 } }),
    })),
    servers: Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => ({
      command: faker.string.alpha({ length: { min: 10, max: 20 } }),
      description: faker.string.alpha({ length: { min: 10, max: 20 } }),
      name: faker.string.alpha({ length: { min: 10, max: 20 } }),
      policy: faker.helpers.arrayElement(Object.values(Policy)),
      preinstalled: faker.datatype.boolean(),
      type: faker.helpers.arrayElement(Object.values(McpServerType)),
      url: faker.string.alpha({ length: { min: 10, max: 20 } }),
    })),
    tenant_name: faker.string.alpha({ length: { min: 10, max: 20 } }),
    tools: Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => ({
      args: Array.from(
        { length: faker.number.int({ min: 1, max: 10 }) },
        (_, i) => i + 1,
      ).map(() => ({})),
      description: faker.string.alpha({ length: { min: 10, max: 20 } }),
      headers: {
        [faker.string.alphanumeric(5)]: faker.string.alpha({
          length: { min: 10, max: 20 },
        }),
      },
      input_schema: {},
      method: faker.string.alpha({ length: { min: 10, max: 20 } }),
      name: faker.string.alpha({ length: { min: 10, max: 20 } }),
      path: faker.string.alpha({ length: { min: 10, max: 20 } }),
      request_body: faker.string.alpha({ length: { min: 10, max: 20 } }),
      response_body: faker.string.alpha({ length: { min: 10, max: 20 } }),
    })),
    updated_at: faker.helpers.arrayElement([
      `${faker.date.past().toISOString().split('.')[0]}Z`,
      null,
    ]),
  }))
}

export function getCreateMcpConfigApiV1McpConfigsPostResponseMock(overrideResponse: Partial<McpConfigModel> = {}): McpConfigModel {
  return {
    created_at: `${faker.date.past().toISOString().split('.')[0]}Z`,
    deleted_at: faker.helpers.arrayElement([
      `${faker.date.past().toISOString().split('.')[0]}Z`,
      null,
    ]),
    gmt_created: `${faker.date.past().toISOString().split('.')[0]}Z`,
    gmt_deleted: faker.helpers.arrayElement([
      faker.helpers.arrayElement([
        `${faker.date.past().toISOString().split('.')[0]}Z`,
        null,
      ]),
      undefined,
    ]),
    gmt_updated: `${faker.date.past().toISOString().split('.')[0]}Z`,
    http_servers: Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => ({
      description: faker.string.alpha({ length: { min: 10, max: 20 } }),
      name: faker.string.alpha({ length: { min: 10, max: 20 } }),
      tools: Array.from(
        { length: faker.number.int({ min: 1, max: 10 }) },
        (_, i) => i + 1,
      ).map(() => faker.string.alpha({ length: { min: 10, max: 20 } })),
      url: faker.string.alpha({ length: { min: 10, max: 20 } }),
    })),
    id: faker.string.alpha({ length: { min: 10, max: 20 } }),
    name: faker.string.alpha({ length: { min: 10, max: 20 } }),
    routers: Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => ({
      cors: {
        allow_credentials: faker.datatype.boolean(),
        allow_headers: Array.from(
          { length: faker.number.int({ min: 1, max: 10 }) },
          (_, i) => i + 1,
        ).map(() => faker.string.alpha({ length: { min: 10, max: 20 } })),
        allow_methods: Array.from(
          { length: faker.number.int({ min: 1, max: 10 }) },
          (_, i) => i + 1,
        ).map(() => faker.string.alpha({ length: { min: 10, max: 20 } })),
        allow_origins: Array.from(
          { length: faker.number.int({ min: 1, max: 10 }) },
          (_, i) => i + 1,
        ).map(() => faker.string.alpha({ length: { min: 10, max: 20 } })),
        expose_headers: Array.from(
          { length: faker.number.int({ min: 1, max: 10 }) },
          (_, i) => i + 1,
        ).map(() => faker.string.alpha({ length: { min: 10, max: 20 } })),
      },
      http_server_ref: {
        description: faker.string.alpha({ length: { min: 10, max: 20 } }),
        name: faker.string.alpha({ length: { min: 10, max: 20 } }),
        tools: Array.from(
          { length: faker.number.int({ min: 1, max: 10 }) },
          (_, i) => i + 1,
        ).map(() => faker.string.alpha({ length: { min: 10, max: 20 } })),
        url: faker.string.alpha({ length: { min: 10, max: 20 } }),
      },
      prefix: faker.string.alpha({ length: { min: 10, max: 20 } }),
      sse_prefix: faker.string.alpha({ length: { min: 10, max: 20 } }),
    })),
    servers: Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => ({
      command: faker.string.alpha({ length: { min: 10, max: 20 } }),
      description: faker.string.alpha({ length: { min: 10, max: 20 } }),
      name: faker.string.alpha({ length: { min: 10, max: 20 } }),
      policy: faker.helpers.arrayElement(Object.values(Policy)),
      preinstalled: faker.datatype.boolean(),
      type: faker.helpers.arrayElement(Object.values(McpServerType)),
      url: faker.string.alpha({ length: { min: 10, max: 20 } }),
    })),
    tenant_name: faker.string.alpha({ length: { min: 10, max: 20 } }),
    tools: Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => ({
      args: Array.from(
        { length: faker.number.int({ min: 1, max: 10 }) },
        (_, i) => i + 1,
      ).map(() => ({})),
      description: faker.string.alpha({ length: { min: 10, max: 20 } }),
      headers: {
        [faker.string.alphanumeric(5)]: faker.string.alpha({
          length: { min: 10, max: 20 },
        }),
      },
      input_schema: {},
      method: faker.string.alpha({ length: { min: 10, max: 20 } }),
      name: faker.string.alpha({ length: { min: 10, max: 20 } }),
      path: faker.string.alpha({ length: { min: 10, max: 20 } }),
      request_body: faker.string.alpha({ length: { min: 10, max: 20 } }),
      response_body: faker.string.alpha({ length: { min: 10, max: 20 } }),
    })),
    updated_at: faker.helpers.arrayElement([
      `${faker.date.past().toISOString().split('.')[0]}Z`,
      null,
    ]),
    ...overrideResponse,
  }
}

export function getUpdateMcpConfigApiV1McpConfigsPutResponseMock(overrideResponse: Partial<McpConfigModel> = {}): McpConfigModel {
  return {
    created_at: `${faker.date.past().toISOString().split('.')[0]}Z`,
    deleted_at: faker.helpers.arrayElement([
      `${faker.date.past().toISOString().split('.')[0]}Z`,
      null,
    ]),
    gmt_created: `${faker.date.past().toISOString().split('.')[0]}Z`,
    gmt_deleted: faker.helpers.arrayElement([
      faker.helpers.arrayElement([
        `${faker.date.past().toISOString().split('.')[0]}Z`,
        null,
      ]),
      undefined,
    ]),
    gmt_updated: `${faker.date.past().toISOString().split('.')[0]}Z`,
    http_servers: Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => ({
      description: faker.string.alpha({ length: { min: 10, max: 20 } }),
      name: faker.string.alpha({ length: { min: 10, max: 20 } }),
      tools: Array.from(
        { length: faker.number.int({ min: 1, max: 10 }) },
        (_, i) => i + 1,
      ).map(() => faker.string.alpha({ length: { min: 10, max: 20 } })),
      url: faker.string.alpha({ length: { min: 10, max: 20 } }),
    })),
    id: faker.string.alpha({ length: { min: 10, max: 20 } }),
    name: faker.string.alpha({ length: { min: 10, max: 20 } }),
    routers: Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => ({
      cors: {
        allow_credentials: faker.datatype.boolean(),
        allow_headers: Array.from(
          { length: faker.number.int({ min: 1, max: 10 }) },
          (_, i) => i + 1,
        ).map(() => faker.string.alpha({ length: { min: 10, max: 20 } })),
        allow_methods: Array.from(
          { length: faker.number.int({ min: 1, max: 10 }) },
          (_, i) => i + 1,
        ).map(() => faker.string.alpha({ length: { min: 10, max: 20 } })),
        allow_origins: Array.from(
          { length: faker.number.int({ min: 1, max: 10 }) },
          (_, i) => i + 1,
        ).map(() => faker.string.alpha({ length: { min: 10, max: 20 } })),
        expose_headers: Array.from(
          { length: faker.number.int({ min: 1, max: 10 }) },
          (_, i) => i + 1,
        ).map(() => faker.string.alpha({ length: { min: 10, max: 20 } })),
      },
      http_server_ref: {
        description: faker.string.alpha({ length: { min: 10, max: 20 } }),
        name: faker.string.alpha({ length: { min: 10, max: 20 } }),
        tools: Array.from(
          { length: faker.number.int({ min: 1, max: 10 }) },
          (_, i) => i + 1,
        ).map(() => faker.string.alpha({ length: { min: 10, max: 20 } })),
        url: faker.string.alpha({ length: { min: 10, max: 20 } }),
      },
      prefix: faker.string.alpha({ length: { min: 10, max: 20 } }),
      sse_prefix: faker.string.alpha({ length: { min: 10, max: 20 } }),
    })),
    servers: Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => ({
      command: faker.string.alpha({ length: { min: 10, max: 20 } }),
      description: faker.string.alpha({ length: { min: 10, max: 20 } }),
      name: faker.string.alpha({ length: { min: 10, max: 20 } }),
      policy: faker.helpers.arrayElement(Object.values(Policy)),
      preinstalled: faker.datatype.boolean(),
      type: faker.helpers.arrayElement(Object.values(McpServerType)),
      url: faker.string.alpha({ length: { min: 10, max: 20 } }),
    })),
    tenant_name: faker.string.alpha({ length: { min: 10, max: 20 } }),
    tools: Array.from(
      { length: faker.number.int({ min: 1, max: 10 }) },
      (_, i) => i + 1,
    ).map(() => ({
      args: Array.from(
        { length: faker.number.int({ min: 1, max: 10 }) },
        (_, i) => i + 1,
      ).map(() => ({})),
      description: faker.string.alpha({ length: { min: 10, max: 20 } }),
      headers: {
        [faker.string.alphanumeric(5)]: faker.string.alpha({
          length: { min: 10, max: 20 },
        }),
      },
      input_schema: {},
      method: faker.string.alpha({ length: { min: 10, max: 20 } }),
      name: faker.string.alpha({ length: { min: 10, max: 20 } }),
      path: faker.string.alpha({ length: { min: 10, max: 20 } }),
      request_body: faker.string.alpha({ length: { min: 10, max: 20 } }),
      response_body: faker.string.alpha({ length: { min: 10, max: 20 } }),
    })),
    updated_at: faker.helpers.arrayElement([
      `${faker.date.past().toISOString().split('.')[0]}Z`,
      null,
    ]),
    ...overrideResponse,
  }
}

export function getListMcpConfigNamesApiV1McpConfigsNamesGetResponseMock(): McpConfigName[] {
  return Array.from(
    { length: faker.number.int({ min: 1, max: 10 }) },
    (_, i) => i + 1,
  ).map(() => ({
    id: faker.string.alpha({ length: { min: 10, max: 20 } }),
    name: faker.string.alpha({ length: { min: 10, max: 20 } }),
    tenant_id: faker.string.alpha({ length: { min: 10, max: 20 } }),
  }))
}

export function getLoginApiV1AuthLoginPostMockHandler(overrideResponse?:
  | unknown
  | ((
    info: Parameters<Parameters<typeof http.post>[1]>[0],
  ) => Promise<unknown> | unknown)) {
  return http.post('*/api/v1/auth/login', async (info) => {
    await delay(1000)
    if (typeof overrideResponse === 'function') {
      await overrideResponse(info)
    }
    return new HttpResponse(null, { status: 200 })
  })
}

export function getLogoutApiV1AuthLogoutPostMockHandler(overrideResponse?:
  | unknown
  | ((
    info: Parameters<Parameters<typeof http.post>[1]>[0],
  ) => Promise<unknown> | unknown)) {
  return http.post('*/api/v1/auth/logout', async (info) => {
    await delay(1000)
    if (typeof overrideResponse === 'function') {
      await overrideResponse(info)
    }
    return new HttpResponse(null, { status: 200 })
  })
}

export function getGetUserApiV1AuthUserGetMockHandler(overrideResponse?:
  | unknown
  | ((
    info: Parameters<Parameters<typeof http.get>[1]>[0],
  ) => Promise<unknown> | unknown)) {
  return http.get('*/api/v1/auth/user', async (info) => {
    await delay(1000)
    if (typeof overrideResponse === 'function') {
      await overrideResponse(info)
    }
    return new HttpResponse(null, { status: 200 })
  })
}

export function getListUsersApiV1AuthUsersGetMockHandler(overrideResponse?:
  | unknown
  | ((
    info: Parameters<Parameters<typeof http.get>[1]>[0],
  ) => Promise<unknown> | unknown)) {
  return http.get('*/api/v1/auth/users', async (info) => {
    await delay(1000)
    if (typeof overrideResponse === 'function') {
      await overrideResponse(info)
    }
    return new HttpResponse(null, { status: 200 })
  })
}

export function getChangePasswordApiV1AuthUsersChangePasswordPostMockHandler(overrideResponse?:
  | unknown
  | ((
    info: Parameters<Parameters<typeof http.post>[1]>[0],
  ) => Promise<unknown> | unknown)) {
  return http.post('*/api/v1/auth/users/change-password', async (info) => {
    await delay(1000)
    if (typeof overrideResponse === 'function') {
      await overrideResponse(info)
    }
    return new HttpResponse(null, { status: 200 })
  })
}

export function getDeleteUserApiV1AuthUsersUserIdDeleteMockHandler(overrideResponse?:
  | unknown
  | ((
    info: Parameters<Parameters<typeof http.delete>[1]>[0],
  ) => Promise<unknown> | unknown)) {
  return http.delete('*/api/v1/auth/users/:userId', async (info) => {
    await delay(1000)
    if (typeof overrideResponse === 'function') {
      await overrideResponse(info)
    }
    return new HttpResponse(null, { status: 200 })
  })
}

export function getListMcpConfigsApiV1McpConfigsGetMockHandler(overrideResponse?:
  | McpConfigModel[]
  | ((
    info: Parameters<Parameters<typeof http.get>[1]>[0],
  ) => Promise<McpConfigModel[]> | McpConfigModel[])) {
  return http.get('*/api/v1/mcp/configs', async (info) => {
    await delay(1000)

    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === 'function'
            ? await overrideResponse(info)
            : overrideResponse
          : getListMcpConfigsApiV1McpConfigsGetResponseMock(),
      ),
      { status: 200, headers: { 'Content-Type': 'application/json' } },
    )
  })
}

export function getCreateMcpConfigApiV1McpConfigsPostMockHandler(overrideResponse?:
  | McpConfigModel
  | ((
    info: Parameters<Parameters<typeof http.post>[1]>[0],
  ) => Promise<McpConfigModel> | McpConfigModel)) {
  return http.post('*/api/v1/mcp/configs', async (info) => {
    await delay(1000)

    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === 'function'
            ? await overrideResponse(info)
            : overrideResponse
          : getCreateMcpConfigApiV1McpConfigsPostResponseMock(),
      ),
      { status: 200, headers: { 'Content-Type': 'application/json' } },
    )
  })
}

export function getUpdateMcpConfigApiV1McpConfigsPutMockHandler(overrideResponse?:
  | McpConfigModel
  | ((
    info: Parameters<Parameters<typeof http.put>[1]>[0],
  ) => Promise<McpConfigModel> | McpConfigModel)) {
  return http.put('*/api/v1/mcp/configs', async (info) => {
    await delay(1000)

    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === 'function'
            ? await overrideResponse(info)
            : overrideResponse
          : getUpdateMcpConfigApiV1McpConfigsPutResponseMock(),
      ),
      { status: 200, headers: { 'Content-Type': 'application/json' } },
    )
  })
}

export function getListMcpConfigNamesApiV1McpConfigsNamesGetMockHandler(overrideResponse?:
  | McpConfigName[]
  | ((
    info: Parameters<Parameters<typeof http.get>[1]>[0],
  ) => Promise<McpConfigName[]> | McpConfigName[])) {
  return http.get('*/api/v1/mcp/configs/names', async (info) => {
    await delay(1000)

    return new HttpResponse(
      JSON.stringify(
        overrideResponse !== undefined
          ? typeof overrideResponse === 'function'
            ? await overrideResponse(info)
            : overrideResponse
          : getListMcpConfigNamesApiV1McpConfigsNamesGetResponseMock(),
      ),
      { status: 200, headers: { 'Content-Type': 'application/json' } },
    )
  })
}

export function getSyncMcpConfigApiV1McpConfigsConfigIdSyncPostMockHandler(overrideResponse?:
  | unknown
  | ((
    info: Parameters<Parameters<typeof http.post>[1]>[0],
  ) => Promise<unknown> | unknown)) {
  return http.post('*/api/v1/mcp/configs/:configId/sync', async (info) => {
    await delay(1000)
    if (typeof overrideResponse === 'function') {
      await overrideResponse(info)
    }
    return new HttpResponse(null, { status: 200 })
  })
}

export function getDeleteMcpConfigApiV1McpConfigsTenantIdNameDeleteMockHandler(overrideResponse?:
  | unknown
  | ((
    info: Parameters<Parameters<typeof http.delete>[1]>[0],
  ) => Promise<unknown> | unknown)) {
  return http.delete('*/api/v1/mcp/configs/:tenantId/:name', async (info) => {
    await delay(1000)
    if (typeof overrideResponse === 'function') {
      await overrideResponse(info)
    }
    return new HttpResponse(null, { status: 200 })
  })
}

export function getActiveMcpConfigApiV1McpTenantNameNameActivePostMockHandler(overrideResponse?:
  | unknown
  | ((
    info: Parameters<Parameters<typeof http.post>[1]>[0],
  ) => Promise<unknown> | unknown)) {
  return http.post('*/api/v1/mcp/:tenantName/:name/active', async (info) => {
    await delay(1000)
    if (typeof overrideResponse === 'function') {
      await overrideResponse(info)
    }
    return new HttpResponse(null, { status: 200 })
  })
}

export function getImportOpenapiApiV1OpenapiOpenapiImportPostMockHandler(overrideResponse?:
  | unknown
  | ((
    info: Parameters<Parameters<typeof http.post>[1]>[0],
  ) => Promise<unknown> | unknown)) {
  return http.post('*/api/v1/openapi/openapi/import', async (info) => {
    await delay(1000)
    if (typeof overrideResponse === 'function') {
      await overrideResponse(info)
    }
    return new HttpResponse(null, { status: 200 })
  })
}
export function getAPIServerMock() {
  return [
    getLoginApiV1AuthLoginPostMockHandler(),
    getLogoutApiV1AuthLogoutPostMockHandler(),
    getGetUserApiV1AuthUserGetMockHandler(),
    getListUsersApiV1AuthUsersGetMockHandler(),
    getChangePasswordApiV1AuthUsersChangePasswordPostMockHandler(),
    getDeleteUserApiV1AuthUsersUserIdDeleteMockHandler(),
    getListMcpConfigsApiV1McpConfigsGetMockHandler(),
    getCreateMcpConfigApiV1McpConfigsPostMockHandler(),
    getUpdateMcpConfigApiV1McpConfigsPutMockHandler(),
    getListMcpConfigNamesApiV1McpConfigsNamesGetMockHandler(),
    getSyncMcpConfigApiV1McpConfigsConfigIdSyncPostMockHandler(),
    getDeleteMcpConfigApiV1McpConfigsTenantIdNameDeleteMockHandler(),
    getActiveMcpConfigApiV1McpTenantNameNameActivePostMockHandler(),
    getImportOpenapiApiV1OpenapiOpenapiImportPostMockHandler(),
  ]
}
